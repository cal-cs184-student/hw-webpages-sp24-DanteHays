<html>
	<head>
	</head>
	<body>
		Website: https://cal-cs184-student.github.io/hw-webpages-sp24-DanteHays/
		

		<p><b>Task 1:</b></p>
		
		<p>The first part of this homework assignment was rasterizing triangles without texture mapping. 
			I was given the x and y coordinates of the three points in each triangle, as well as the color, and had to fill a buffer with all of the pixels to draw it. 
			My algorithm begins by finding the minimum and maximum x and y values of the surrounding box around the triangle (so I'm not checking every pixel on the screen). 
			Once these coordinates are found, the algorithm iterates through each pixel in the box and uses "three line tests" to determine if the pixel is in the triangle. 
			Each line test is done on one of the sides of the triangle, and it finds the equation for the normal vector to each line and takes a dot product of the normal vector and the vector to the pixel.
			It returns positive if the pixel is above the line and negative if the pixel is below the line.
			If all three lines return a positive value, then the point is inside the triangle, and I add the color to the respective index in the buffer.
			This math only works when the points of the triangle are given in counter-clockwise orientation, however, so if the cross product of two of the lines is negative, I flip the order of the triangle points, and then run the line tests. 
			Before I realized this, only the counter-clockwise constructed triangles rendered properly. I also noticed that instead of taking the cross proudct, you could just test if the line tests return all positive or all negative. 
			If drawn in the counter-clockwise way, then it would return all positive. But, if drawn in the clockwise way, the normal vectors and dot product flip, so it would all negative. 
			Which is equivalent to swaping the points and having it return all positive. </p>
		<p>If I didn't find the bounding box of the triangle, my algorithm would run significantly slower, as it would be running line tests for every pixel on the screen for each triangle. 
			Each pixel would get tested n number of times, where n is the number of pixels on the screen. Now, they only get tested a handful of times each, depending on where the bounding boxes are per picture.</p>

		<p><b>Task 2:</b></p>
		
		<p>To implement supersampling, I built off of task 1. 
			As I iterate through each pixel, I split the pixel up into "subpixels". 
			The sample rate determines how many subpixels there are. 
			I iterate through each subpixel and find the location of the new subpixel coordinates. 
			Then, I run the line tests on each subpixel for each pixel in the bounding triangle box. 
			The buffer has to be resized whenever the sample rate changes, as it keeps track of all of the subpixels colors. 
			Then, once the buffer has been filled and the screen is actually rendered, I average the values of the subpixels for each pixel. 
			Supersampling is used to smooth out edges and make lines look straight instead of jaggy. 
			This change is especially noticable on the edges of the picture when it isn't a vertical or horizontal line. 
			By averaging, the pixels that are partly in the triangle and partly not get placed at a lighter color than one that's fully in, making the edges look smooth. </p>
		
		<p><b>Task 3:</b></p>
		<p><b>Task 4:</b></p>

		<p> </p>
		
		<p><b>Task 5:</b></p>

		<p>Pixel sampling can be used to map a texture map to a new image. 
			It can be used to distort images and cause twists in them, for example. 
			Basically, when you know the coordinates of a triangle in your picture and the coordinates of the respective triangle in a texture, you can "copy" the triangle over while allowing the triangle shape to change (hence the distortions). 
			I utilized the Barycentric coordinates from task 4 to find the ratios of where each pixel is to the points on the triangle in my picture. 
			Then, I used the ratios to find the location of the "equivalent" pixel on the texture map by combining the ratios with the texture map traingle point coordinates. Then, I was able to find the correct color (2 ways to do this, nearest and bilinear) from the texture map and place it into the buffer. The rest of the process remains the same.
			There are two types of pixel sampling methods (nearest and bilinear). 
			The x and y value found after finding the equivalent point on the texture map is typically not an integer. 
			When using the nearest pixel sampling technique, the x and y coordinate can just be rounded to find the nearest pixel on the texture map. The color of this pixel is placed in the buffer.
			However, bilinear pixel sampling is slightly more difficult. In this case, the colors of the four pixels on the texture map that surround the x and y coordinates are found. 
			Then the bottom two and top two colors are linearly interpolated in the horizontal direction given the actual x value. Finally, these two interpolated colors are interpolated once more in the vertical direction based off of the actual y value. This is the color placed in the buffer.</p>
		
		<p><b>Task 6:</b></p>
	</body>
</html>
